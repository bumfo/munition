<!DOCTYPE html>
<title>munition</title>

<meta name="viewport" content="user-scalable=no, initial-scale=1">

<style>
  html { overflow: hidden; background: #ddd; }
  html, body { margin: 0; padding: 0; }
</style>

<canvas></canvas>

<script src="s/module.js"></script>
<script src="s/vector.js"></script>
<script src="s/body.js"></script>
<script src="s/draw.js"></script>
<script>
'use strict';

(function() {
	var mousePos = Vector(0,0);

	var tank = new Tank({velocity: Vector(-5,-5), gun: {cooldown: 0.8, headingFix: 2}, toPos: mousePos}),
		robot = new Tank({velocity: Vector(5,5), gun: {cooldown: 0.8, headingFix: 2}});

	tank.target = robot;
	robot.target = tank;

	var tanks = [robot, tank], bullets = [], explosions = [],
		objs = [tanks, bullets, explosions];

	bullets.subdivision = 5;
	explosions.noCollision = true;

	console.log(tank);

	window.addEventListener("mousemove", function(e) {
		mousePos.x = e.pageX;
		mousePos.y = e.pageY;
	});

	window.addEventListener("touchstart", function(e) {
		e.preventDefault();

		mousePos.x = e.pageX;
		mousePos.y = e.pageY;
	});

	window.addEventListener("touchmove", function(e) {
		e.preventDefault();

		mousePos.x = e.pageX;
		mousePos.y = e.pageY;
	});

	window.addEventListener("mousemove", function(e) {
		mousePos.x = e.pageX;
		mousePos.y = e.pageY;
	});

	var width = window.innerWidth, height = window.innerHeight;

	extend(Body.prototype, {
		inFieldX: function(x, radius) {
			return radius <= x && x <= width-radius;
		},
		inFieldY: function(y, radius) {
			return radius <= y && y <= height-radius;
		},
		limitField: function(pos, radius) {
			if (pos.x < radius)
				pos.x = radius;
			else if (pos.x > width-radius)
				pos.x = width-radius;
			if (pos.y < radius)
				pos.y = radius;
			else if (pos.y > height-radius)
				pos.y = height-radius;
		}
	});

	Gun.prototype.shell = function(shell) {
		bullets.push(shell);
	};

	Projectile.prototype.shell = function(shell) {
		explosions.push(shell);
	};

	Projectile.prototype.remove = function() {
		var index = bullets.indexOf(this);

		if (index !== -1) {
			bullets.splice(index, 1);
		}
	};

	Explosion.prototype.remove = function() {
		var index = explosions.indexOf(this);

		if (index !== -1) {
			explosions.splice(index, 1);
		}
	};

	var draw = new Draw(width, height);

	requestAnimationFrame(function(t) {
		var t0 = t, tt = t;

		var fCount = 0;

		console.log(t0);

		requestAnimationFrame(function frame(t1) {
			++fCount;

			var t = t1 - t0, dt = t1 - tt;
			tt = t1;

			// if (fCount%10 !== 0) {
			// 	requestAnimationFrame(frame);
			// 	return;
			// }

			var dtp = dt/1000*60, tp = t/1000*60;

			var scale = 1;

			dtp *= scale;
			tp *= scale;

			objs.forEach(function(y) {
				y.forEach(function(x) {
					x.clear(draw.ctx);
				});
			});
			function detectCollision(o) {
				if (o.noCollision)
					return;
				for (var i = 0, n = o.length; i < n; ++i) {
					var x = o[i];
					for (var j = i+1, m = o.length; j < m; ++j) {
						x.detectImpact(o[j]);
					}
				}
			}
			function update(y, dtp, tp) {
				var i = 0, yi;
				detectCollision(y);

				while (yi = y[i]) {
					yi.update(dtp, tp);
					if (yi === y[i])
						i++;
				}

				// y.forEach(function(x) {
				// 	x.update(dtp, tp);
				// });
			}

			objs.forEach(function(y) {
				var dtpn = dtp, n = y.subdivision;

				if (n > 1) {
					dtpn = 1/n;

					for (var j = 0; j < n; ++j) {
						update(y, dtpn, NaN);
					}
				} else {
					update(y, dtp, tp);
				}
			});

			objs.forEach(function(y) {
				y.forEach(function(x) {
					x.draw(draw.ctx);
				});
			});

			var va1 = (1+Math.sin(tp/480*Math.PI*2))/2;
			var va2 = (1+Math.sin(tp/480*Math.PI*2+678346))/2;

			var k = 0.9;

			robot.gun.cooldown = (0.9-k)+k*va1;
			tank.gun.cooldown = (0.9-k)+k*va2;

			requestAnimationFrame(frame);
		});
	});
}.call(this));
</script>
